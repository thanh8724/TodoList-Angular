/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
/* eslint-disable @angular-eslint/component-selector */
import { NgForOf } from '@angular/common';
import { ChangeDetectionStrategy, Component, EventEmitter, Input, NgZone, Output, ViewChildren, ViewEncapsulation } from '@angular/core';
import { Subject, combineLatest } from 'rxjs';
import { debounceTime, map, startWith, switchMap, takeUntil } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "ng-zorro-antd/cdk/resize-observer";
export class NzTrMeasureComponent {
    constructor(nzResizeObserver, ngZone) {
        this.nzResizeObserver = nzResizeObserver;
        this.ngZone = ngZone;
        this.listOfMeasureColumn = [];
        this.listOfAutoWidth = new EventEmitter();
        this.destroy$ = new Subject();
    }
    trackByFunc(_, key) {
        return key;
    }
    ngAfterViewInit() {
        this.listOfTdElement.changes
            .pipe(startWith(this.listOfTdElement))
            .pipe(switchMap(list => combineLatest(list.toArray().map((item) => this.nzResizeObserver.observe(item).pipe(map(([entry]) => {
            const { width } = entry.target.getBoundingClientRect();
            return Math.floor(width);
        }))))), debounceTime(16), takeUntil(this.destroy$))
            .subscribe(data => {
            // Caretaker note: we don't have to re-enter the Angular zone each time the stream emits.
            // The below check is necessary to be sure that zone is not nooped through `BootstrapOptions`
            // (`bootstrapModule(AppModule, { ngZone: 'noop' }))`. The `ngZone instanceof NgZone` may return
            // `false` if zone is nooped, since `ngZone` will be an instance of the `NoopNgZone`.
            // The `ResizeObserver` might be also patched through `zone.js/dist/zone-patch-resize-observer`,
            // thus calling `ngZone.run` again will cause another change detection.
            if (this.ngZone instanceof NgZone && NgZone.isInAngularZone()) {
                this.listOfAutoWidth.next(data);
            }
            else {
                this.ngZone.run(() => this.listOfAutoWidth.next(data));
            }
        });
    }
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: NzTrMeasureComponent, deps: [{ token: i1.NzResizeObserver }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.8", type: NzTrMeasureComponent, isStandalone: true, selector: "tr[nz-table-measure-row]", inputs: { listOfMeasureColumn: "listOfMeasureColumn" }, outputs: { listOfAutoWidth: "listOfAutoWidth" }, host: { classAttribute: "ant-table-measure-now" }, viewQueries: [{ propertyName: "listOfTdElement", predicate: ["tdElement"], descendants: true }], ngImport: i0, template: `
    <td
      #tdElement
      class="nz-disable-td"
      style="padding: 0px; border: 0px; height: 0px;"
      *ngFor="let th of listOfMeasureColumn; trackBy: trackByFunc"
    ></td>
  `, isInline: true, dependencies: [{ kind: "directive", type: NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: NzTrMeasureComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'tr[nz-table-measure-row]',
                    preserveWhitespaces: false,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                    template: `
    <td
      #tdElement
      class="nz-disable-td"
      style="padding: 0px; border: 0px; height: 0px;"
      *ngFor="let th of listOfMeasureColumn; trackBy: trackByFunc"
    ></td>
  `,
                    host: { class: 'ant-table-measure-now' },
                    imports: [NgForOf],
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.NzResizeObserver }, { type: i0.NgZone }], propDecorators: { listOfMeasureColumn: [{
                type: Input
            }], listOfAutoWidth: [{
                type: Output
            }], listOfTdElement: [{
                type: ViewChildren,
                args: ['tdElement']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHItbWVhc3VyZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9jb21wb25lbnRzL3RhYmxlL3NyYy90YWJsZS90ci1tZWFzdXJlLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0dBR0c7QUFFSCx1REFBdUQ7QUFFdkQsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzFDLE9BQU8sRUFFTCx1QkFBdUIsRUFDdkIsU0FBUyxFQUVULFlBQVksRUFDWixLQUFLLEVBQ0wsTUFBTSxFQUVOLE1BQU0sRUFFTixZQUFZLEVBQ1osaUJBQWlCLEVBQ2xCLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBYyxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzFELE9BQU8sRUFBRSxZQUFZLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7OztBQXFCcEYsTUFBTSxPQUFPLG9CQUFvQjtJQUsvQixZQUNVLGdCQUFrQyxFQUNsQyxNQUFjO1FBRGQscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFrQjtRQUNsQyxXQUFNLEdBQU4sTUFBTSxDQUFRO1FBTmYsd0JBQW1CLEdBQXNCLEVBQUUsQ0FBQztRQUNsQyxvQkFBZSxHQUFHLElBQUksWUFBWSxFQUFZLENBQUM7UUFFMUQsYUFBUSxHQUFHLElBQUksT0FBTyxFQUFXLENBQUM7SUFJdkMsQ0FBQztJQUNKLFdBQVcsQ0FBQyxDQUFTLEVBQUUsR0FBVztRQUNoQyxPQUFPLEdBQUcsQ0FBQztJQUNiLENBQUM7SUFDRCxlQUFlO1FBQ2IsSUFBSSxDQUFDLGVBQWUsQ0FBQyxPQUFPO2FBQ3pCLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO2FBQ3JDLElBQUksQ0FDSCxTQUFTLENBQ1AsSUFBSSxDQUFDLEVBQUUsQ0FDTCxhQUFhLENBQ1gsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQWdCLEVBQUUsRUFBRSxDQUN0QyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FDdEMsR0FBRyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFO1lBQ2QsTUFBTSxFQUFFLEtBQUssRUFBRSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMscUJBQXFCLEVBQUUsQ0FBQztZQUN2RCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDM0IsQ0FBQyxDQUFDLENBQ0gsQ0FDRixDQUNzQixDQUM1QixFQUNELFlBQVksQ0FBQyxFQUFFLENBQUMsRUFDaEIsU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FDekI7YUFDQSxTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDaEIseUZBQXlGO1lBQ3pGLDZGQUE2RjtZQUM3RixnR0FBZ0c7WUFDaEcscUZBQXFGO1lBQ3JGLGdHQUFnRztZQUNoRyx1RUFBdUU7WUFDdkUsSUFBSSxJQUFJLENBQUMsTUFBTSxZQUFZLE1BQU0sSUFBSSxNQUFNLENBQUMsZUFBZSxFQUFFLEVBQUUsQ0FBQztnQkFDOUQsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDbEMsQ0FBQztpQkFBTSxDQUFDO2dCQUNOLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7WUFDekQsQ0FBQztRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUNELFdBQVc7UUFDVCxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN6QixJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQzNCLENBQUM7OEdBakRVLG9CQUFvQjtrR0FBcEIsb0JBQW9CLGlWQVpyQjs7Ozs7OztHQU9ULDREQUVTLE9BQU87OzJGQUdOLG9CQUFvQjtrQkFqQmhDLFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLDBCQUEwQjtvQkFDcEMsbUJBQW1CLEVBQUUsS0FBSztvQkFDMUIsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07b0JBQy9DLGFBQWEsRUFBRSxpQkFBaUIsQ0FBQyxJQUFJO29CQUNyQyxRQUFRLEVBQUU7Ozs7Ozs7R0FPVDtvQkFDRCxJQUFJLEVBQUUsRUFBRSxLQUFLLEVBQUUsdUJBQXVCLEVBQUU7b0JBQ3hDLE9BQU8sRUFBRSxDQUFDLE9BQU8sQ0FBQztvQkFDbEIsVUFBVSxFQUFFLElBQUk7aUJBQ2pCOzBHQUVVLG1CQUFtQjtzQkFBM0IsS0FBSztnQkFDYSxlQUFlO3NCQUFqQyxNQUFNO2dCQUNvQixlQUFlO3NCQUF6QyxZQUFZO3VCQUFDLFdBQVciLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9ORy1aT1JSTy9uZy16b3Jyby1hbnRkL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBAYW5ndWxhci1lc2xpbnQvY29tcG9uZW50LXNlbGVjdG9yICovXG5cbmltcG9ydCB7IE5nRm9yT2YgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtcbiAgQWZ0ZXJWaWV3SW5pdCxcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENvbXBvbmVudCxcbiAgRWxlbWVudFJlZixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgTmdab25lLFxuICBPbkRlc3Ryb3ksXG4gIE91dHB1dCxcbiAgUXVlcnlMaXN0LFxuICBWaWV3Q2hpbGRyZW4sXG4gIFZpZXdFbmNhcHN1bGF0aW9uXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3ViamVjdCwgY29tYmluZUxhdGVzdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZGVib3VuY2VUaW1lLCBtYXAsIHN0YXJ0V2l0aCwgc3dpdGNoTWFwLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IE56UmVzaXplT2JzZXJ2ZXIgfSBmcm9tICduZy16b3Jyby1hbnRkL2Nkay9yZXNpemUtb2JzZXJ2ZXInO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICd0cltuei10YWJsZS1tZWFzdXJlLXJvd10nLFxuICBwcmVzZXJ2ZVdoaXRlc3BhY2VzOiBmYWxzZSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gIHRlbXBsYXRlOiBgXG4gICAgPHRkXG4gICAgICAjdGRFbGVtZW50XG4gICAgICBjbGFzcz1cIm56LWRpc2FibGUtdGRcIlxuICAgICAgc3R5bGU9XCJwYWRkaW5nOiAwcHg7IGJvcmRlcjogMHB4OyBoZWlnaHQ6IDBweDtcIlxuICAgICAgKm5nRm9yPVwibGV0IHRoIG9mIGxpc3RPZk1lYXN1cmVDb2x1bW47IHRyYWNrQnk6IHRyYWNrQnlGdW5jXCJcbiAgICA+PC90ZD5cbiAgYCxcbiAgaG9zdDogeyBjbGFzczogJ2FudC10YWJsZS1tZWFzdXJlLW5vdycgfSxcbiAgaW1wb3J0czogW05nRm9yT2ZdLFxuICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIE56VHJNZWFzdXJlQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcbiAgQElucHV0KCkgbGlzdE9mTWVhc3VyZUNvbHVtbjogcmVhZG9ubHkgc3RyaW5nW10gPSBbXTtcbiAgQE91dHB1dCgpIHJlYWRvbmx5IGxpc3RPZkF1dG9XaWR0aCA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyW10+KCk7XG4gIEBWaWV3Q2hpbGRyZW4oJ3RkRWxlbWVudCcpIGxpc3RPZlRkRWxlbWVudCE6IFF1ZXJ5TGlzdDxFbGVtZW50UmVmPjtcbiAgcHJpdmF0ZSBkZXN0cm95JCA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgbnpSZXNpemVPYnNlcnZlcjogTnpSZXNpemVPYnNlcnZlcixcbiAgICBwcml2YXRlIG5nWm9uZTogTmdab25lXG4gICkge31cbiAgdHJhY2tCeUZ1bmMoXzogbnVtYmVyLCBrZXk6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGtleTtcbiAgfVxuICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgdGhpcy5saXN0T2ZUZEVsZW1lbnQuY2hhbmdlc1xuICAgICAgLnBpcGUoc3RhcnRXaXRoKHRoaXMubGlzdE9mVGRFbGVtZW50KSlcbiAgICAgIC5waXBlKFxuICAgICAgICBzd2l0Y2hNYXAoXG4gICAgICAgICAgbGlzdCA9PlxuICAgICAgICAgICAgY29tYmluZUxhdGVzdChcbiAgICAgICAgICAgICAgbGlzdC50b0FycmF5KCkubWFwKChpdGVtOiBFbGVtZW50UmVmKSA9PlxuICAgICAgICAgICAgICAgIHRoaXMubnpSZXNpemVPYnNlcnZlci5vYnNlcnZlKGl0ZW0pLnBpcGUoXG4gICAgICAgICAgICAgICAgICBtYXAoKFtlbnRyeV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB3aWR0aCB9ID0gZW50cnkudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih3aWR0aCk7XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSBhcyBPYnNlcnZhYmxlPG51bWJlcltdPlxuICAgICAgICApLFxuICAgICAgICBkZWJvdW5jZVRpbWUoMTYpLFxuICAgICAgICB0YWtlVW50aWwodGhpcy5kZXN0cm95JClcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUoZGF0YSA9PiB7XG4gICAgICAgIC8vIENhcmV0YWtlciBub3RlOiB3ZSBkb24ndCBoYXZlIHRvIHJlLWVudGVyIHRoZSBBbmd1bGFyIHpvbmUgZWFjaCB0aW1lIHRoZSBzdHJlYW0gZW1pdHMuXG4gICAgICAgIC8vIFRoZSBiZWxvdyBjaGVjayBpcyBuZWNlc3NhcnkgdG8gYmUgc3VyZSB0aGF0IHpvbmUgaXMgbm90IG5vb3BlZCB0aHJvdWdoIGBCb290c3RyYXBPcHRpb25zYFxuICAgICAgICAvLyAoYGJvb3RzdHJhcE1vZHVsZShBcHBNb2R1bGUsIHsgbmdab25lOiAnbm9vcCcgfSkpYC4gVGhlIGBuZ1pvbmUgaW5zdGFuY2VvZiBOZ1pvbmVgIG1heSByZXR1cm5cbiAgICAgICAgLy8gYGZhbHNlYCBpZiB6b25lIGlzIG5vb3BlZCwgc2luY2UgYG5nWm9uZWAgd2lsbCBiZSBhbiBpbnN0YW5jZSBvZiB0aGUgYE5vb3BOZ1pvbmVgLlxuICAgICAgICAvLyBUaGUgYFJlc2l6ZU9ic2VydmVyYCBtaWdodCBiZSBhbHNvIHBhdGNoZWQgdGhyb3VnaCBgem9uZS5qcy9kaXN0L3pvbmUtcGF0Y2gtcmVzaXplLW9ic2VydmVyYCxcbiAgICAgICAgLy8gdGh1cyBjYWxsaW5nIGBuZ1pvbmUucnVuYCBhZ2FpbiB3aWxsIGNhdXNlIGFub3RoZXIgY2hhbmdlIGRldGVjdGlvbi5cbiAgICAgICAgaWYgKHRoaXMubmdab25lIGluc3RhbmNlb2YgTmdab25lICYmIE5nWm9uZS5pc0luQW5ndWxhclpvbmUoKSkge1xuICAgICAgICAgIHRoaXMubGlzdE9mQXV0b1dpZHRoLm5leHQoZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHRoaXMubGlzdE9mQXV0b1dpZHRoLm5leHQoZGF0YSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLmRlc3Ryb3kkLm5leHQodHJ1ZSk7XG4gICAgdGhpcy5kZXN0cm95JC5jb21wbGV0ZSgpO1xuICB9XG59XG4iXX0=
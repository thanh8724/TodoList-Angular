/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
import { NgIf, NgTemplateOutlet } from '@angular/common';
import { Component, EventEmitter, Input, Output } from '@angular/core';
import { PickerComponent } from './components/picker.component';
import { SliderComponent } from './components/slider.component';
import { NgAntdColorBlockComponent } from './ng-antd-color-block.component';
import { defaultColor, generateColor } from './util/util';
import * as i0 from "@angular/core";
export class NgAntdColorPickerComponent {
    constructor(cdr) {
        this.cdr = cdr;
        this.nzOnChange = new EventEmitter();
        this.nzOnChangeComplete = new EventEmitter();
        this.panelRenderHeader = null;
        this.panelRenderFooter = null;
        this.disabledAlpha = false;
        this.disabled = false;
        this.colorValue = null;
        this.alphaColor = '';
        this.hueColor = [
            'rgb(255, 0, 0) 0%',
            'rgb(255, 255, 0) 17%',
            'rgb(0, 255, 0) 33%',
            'rgb(0, 255, 255) 50%',
            'rgb(0, 0, 255) 67%',
            'rgb(255, 0, 255) 83%',
            'rgb(255, 0, 0) 100%'
        ];
        this.gradientColors = ['rgba(255, 0, 4, 0) 0%', this.alphaColor];
        this.toRgbString = this.colorValue?.toRgbString() || '';
    }
    ngOnInit() {
        this.setColorValue(this.value);
    }
    ngOnChanges(changes) {
        const { value, defaultValue } = changes;
        if (value || defaultValue) {
            this.setColorValue(this.value);
        }
    }
    hasValue(value) {
        return !!value;
    }
    setColorValue(color) {
        let mergeState;
        if (this.hasValue(color)) {
            mergeState = color;
        }
        else if (this.hasValue(this.defaultValue)) {
            mergeState = this.defaultValue;
        }
        else {
            mergeState = defaultColor;
        }
        this.colorValue = generateColor(mergeState);
        this.setAlphaColor(this.colorValue);
        this.toRgbString = this.colorValue?.toRgbString() || '';
        this.cdr.detectChanges();
    }
    setAlphaColor(colorValue) {
        const rgb = generateColor(colorValue.toRgbString());
        this.alphaColor = rgb.toRgbString();
        this.gradientColors = ['rgba(255, 0, 4, 0) 0%', this.alphaColor];
        this.cdr.markForCheck();
    }
    handleChange(color, type) {
        this.setColorValue(color);
        this.nzOnChange.emit({ color, type });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: NgAntdColorPickerComponent, deps: [{ token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.8", type: NgAntdColorPickerComponent, isStandalone: true, selector: "ng-antd-color-picker", inputs: { value: "value", defaultValue: "defaultValue", panelRenderHeader: "panelRenderHeader", panelRenderFooter: "panelRenderFooter", disabledAlpha: "disabledAlpha", disabled: "disabled" }, outputs: { nzOnChange: "nzOnChange", nzOnChangeComplete: "nzOnChangeComplete" }, usesOnChanges: true, ngImport: i0, template: `
    <div class="ant-color-picker-panel" [class.ant-color-picker-panel-disabled]="disabled">
      <ng-container *ngIf="panelRenderHeader">
        <ng-template [ngTemplateOutlet]="panelRenderHeader"></ng-template>
      </ng-container>
      <color-picker
        [color]="colorValue"
        (nzOnChange)="handleChange($event)"
        [disabled]="disabled"
        (nzOnChangeComplete)="nzOnChangeComplete.emit($event)"
      ></color-picker>
      <div class="ant-color-picker-slider-container">
        <div class="ant-color-picker-slider-group" [class.ant-color-picker-slider-group-disabled-alpha]="disabledAlpha">
          <color-slider
            [color]="colorValue"
            [value]="'hsl(' + colorValue?.toHsb()?.h + ',100%, 50%)'"
            [gradientColors]="hueColor"
            (nzOnChange)="handleChange($event, 'hue')"
            [disabled]="disabled"
            (nzOnChangeComplete)="nzOnChangeComplete.emit($event)"
          ></color-slider>
          <ng-container *ngIf="!disabledAlpha">
            <color-slider
              type="alpha"
              [color]="colorValue"
              [value]="toRgbString"
              [gradientColors]="gradientColors"
              (nzOnChange)="handleChange($event, 'alpha')"
              [disabled]="disabled"
              (nzOnChangeComplete)="nzOnChangeComplete.emit($event)"
            ></color-slider>
          </ng-container>
        </div>
        <ng-antd-color-block [color]="toRgbString"></ng-antd-color-block>
      </div>
      <ng-container *ngIf="panelRenderFooter">
        <ng-template [ngTemplateOutlet]="panelRenderFooter"></ng-template>
      </ng-container>
    </div>
  `, isInline: true, dependencies: [{ kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: PickerComponent, selector: "color-picker", inputs: ["color", "disabled"], outputs: ["nzOnChange", "nzOnChangeComplete"] }, { kind: "component", type: SliderComponent, selector: "color-slider", inputs: ["gradientColors", "direction", "type", "color", "value", "disabled"], outputs: ["nzOnChange", "nzOnChangeComplete"] }, { kind: "component", type: NgAntdColorBlockComponent, selector: "ng-antd-color-block", inputs: ["color"], outputs: ["nzOnClick"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: NgAntdColorPickerComponent, decorators: [{
            type: Component,
            args: [{
                    // eslint-disable-next-line @angular-eslint/component-selector
                    selector: 'ng-antd-color-picker',
                    standalone: true,
                    imports: [NgIf, PickerComponent, SliderComponent, NgAntdColorBlockComponent, NgTemplateOutlet],
                    template: `
    <div class="ant-color-picker-panel" [class.ant-color-picker-panel-disabled]="disabled">
      <ng-container *ngIf="panelRenderHeader">
        <ng-template [ngTemplateOutlet]="panelRenderHeader"></ng-template>
      </ng-container>
      <color-picker
        [color]="colorValue"
        (nzOnChange)="handleChange($event)"
        [disabled]="disabled"
        (nzOnChangeComplete)="nzOnChangeComplete.emit($event)"
      ></color-picker>
      <div class="ant-color-picker-slider-container">
        <div class="ant-color-picker-slider-group" [class.ant-color-picker-slider-group-disabled-alpha]="disabledAlpha">
          <color-slider
            [color]="colorValue"
            [value]="'hsl(' + colorValue?.toHsb()?.h + ',100%, 50%)'"
            [gradientColors]="hueColor"
            (nzOnChange)="handleChange($event, 'hue')"
            [disabled]="disabled"
            (nzOnChangeComplete)="nzOnChangeComplete.emit($event)"
          ></color-slider>
          <ng-container *ngIf="!disabledAlpha">
            <color-slider
              type="alpha"
              [color]="colorValue"
              [value]="toRgbString"
              [gradientColors]="gradientColors"
              (nzOnChange)="handleChange($event, 'alpha')"
              [disabled]="disabled"
              (nzOnChangeComplete)="nzOnChangeComplete.emit($event)"
            ></color-slider>
          </ng-container>
        </div>
        <ng-antd-color-block [color]="toRgbString"></ng-antd-color-block>
      </div>
      <ng-container *ngIf="panelRenderFooter">
        <ng-template [ngTemplateOutlet]="panelRenderFooter"></ng-template>
      </ng-container>
    </div>
  `
                }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }], propDecorators: { value: [{
                type: Input
            }], defaultValue: [{
                type: Input
            }], nzOnChange: [{
                type: Output
            }], nzOnChangeComplete: [{
                type: Output
            }], panelRenderHeader: [{
                type: Input
            }], panelRenderFooter: [{
                type: Input
            }], disabledAlpha: [{
                type: Input
            }], disabled: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmctYW50ZC1jb2xvci1waWNrZXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vY29tcG9uZW50cy9jb2xvci1waWNrZXIvc3JjL25nLWFudGQtY29sb3ItcGlja2VyLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7O0dBR0c7QUFFSCxPQUFPLEVBQUUsSUFBSSxFQUFFLGdCQUFnQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDekQsT0FBTyxFQUVMLFNBQVMsRUFDVCxZQUFZLEVBQ1osS0FBSyxFQUdMLE1BQU0sRUFHUCxNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFDaEUsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLCtCQUErQixDQUFDO0FBR2hFLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxNQUFNLGlDQUFpQyxDQUFDO0FBQzVFLE9BQU8sRUFBRSxZQUFZLEVBQUUsYUFBYSxFQUFFLE1BQU0sYUFBYSxDQUFDOztBQWdEMUQsTUFBTSxPQUFPLDBCQUEwQjtJQTJCckMsWUFBb0IsR0FBc0I7UUFBdEIsUUFBRyxHQUFILEdBQUcsQ0FBbUI7UUF4QnZCLGVBQVUsR0FBRyxJQUFJLFlBQVksRUFBMEMsQ0FBQztRQUN4RSx1QkFBa0IsR0FBRyxJQUFJLFlBQVksRUFBaUIsQ0FBQztRQUNqRSxzQkFBaUIsR0FBNkIsSUFBSSxDQUFDO1FBQ25ELHNCQUFpQixHQUE2QixJQUFJLENBQUM7UUFDbkQsa0JBQWEsR0FBWSxLQUFLLENBQUM7UUFDL0IsYUFBUSxHQUFZLEtBQUssQ0FBQztRQUVuQyxlQUFVLEdBQWlCLElBQUksQ0FBQztRQUNoQyxlQUFVLEdBQVcsRUFBRSxDQUFDO1FBRXhCLGFBQVEsR0FBYTtZQUNuQixtQkFBbUI7WUFDbkIsc0JBQXNCO1lBQ3RCLG9CQUFvQjtZQUNwQixzQkFBc0I7WUFDdEIsb0JBQW9CO1lBQ3BC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O3NCQUFwQixLQUFLO2dCQUNhLFVBQVU7c0JBQTVCLE1BQU07Z0JBQ1ksa0JBQWtCO3NCQUFwQyxNQUFNO2dCQUNFLGlCQUFpQjtzQkFBekIsS0FBSztnQkFDRyxpQkFBaUI7c0JBQXpCLEtBQUs7Z0JBQ0csYUFBYTtzQkFBckIsS0FBSztnQkFDRyxRQUFRO3NCQUFoQixLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2dpdGh1Yi5jb20vTkctWk9SUk8vbmctem9ycm8tYW50ZC9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKi9cblxuaW1wb3J0IHsgTmdJZiwgTmdUZW1wbGF0ZU91dGxldCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgQ29tcG9uZW50LFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBPbkNoYW5nZXMsXG4gIE9uSW5pdCxcbiAgT3V0cHV0LFxuICBTaW1wbGVDaGFuZ2VzLFxuICBUZW1wbGF0ZVJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgUGlja2VyQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL3BpY2tlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2xpZGVyQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL3NsaWRlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuL2ludGVyZmFjZXMvY29sb3InO1xuaW1wb3J0IHsgQ29sb3JHZW5JbnB1dCwgQ29sb3JWYWx1ZSwgSHNiYUNvbG9yVHlwZSB9IGZyb20gJy4vaW50ZXJmYWNlcy90eXBlJztcbmltcG9ydCB7IE5nQW50ZENvbG9yQmxvY2tDb21wb25lbnQgfSBmcm9tICcuL25nLWFudGQtY29sb3ItYmxvY2suY29tcG9uZW50JztcbmltcG9ydCB7IGRlZmF1bHRDb2xvciwgZ2VuZXJhdGVDb2xvciB9IGZyb20gJy4vdXRpbC91dGlsJztcblxuQENvbXBvbmVudCh7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAYW5ndWxhci1lc2xpbnQvY29tcG9uZW50LXNlbGVjdG9yXG4gIHNlbGVjdG9yOiAnbmctYW50ZC1jb2xvci1waWNrZXInLFxuICBzdGFuZGFsb25lOiB0cnVlLFxuICBpbXBvcnRzOiBbTmdJZiwgUGlja2VyQ29tcG9uZW50LCBTbGlkZXJDb21wb25lbnQsIE5nQW50ZENvbG9yQmxvY2tDb21wb25lbnQsIE5nVGVtcGxhdGVPdXRsZXRdLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxkaXYgY2xhc3M9XCJhbnQtY29sb3ItcGlja2VyLXBhbmVsXCIgW2NsYXNzLmFudC1jb2xvci1waWNrZXItcGFuZWwtZGlzYWJsZWRdPVwiZGlzYWJsZWRcIj5cbiAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJwYW5lbFJlbmRlckhlYWRlclwiPlxuICAgICAgICA8bmctdGVtcGxhdGUgW25nVGVtcGxhdGVPdXRsZXRdPVwicGFuZWxSZW5kZXJIZWFkZXJcIj48L25nLXRlbXBsYXRlPlxuICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICA8Y29sb3ItcGlja2VyXG4gICAgICAgIFtjb2xvcl09XCJjb2xvclZhbHVlXCJcbiAgICAgICAgKG56T25DaGFuZ2UpPVwiaGFuZGxlQ2hhbmdlKCRldmVudClcIlxuICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAobnpPbkNoYW5nZUNvbXBsZXRlKT1cIm56T25DaGFuZ2VDb21wbGV0ZS5lbWl0KCRldmVudClcIlxuICAgICAgPjwvY29sb3ItcGlja2VyPlxuICAgICAgPGRpdiBjbGFzcz1cImFudC1jb2xvci1waWNrZXItc2xpZGVyLWNvbnRhaW5lclwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiYW50LWNvbG9yLXBpY2tlci1zbGlkZXItZ3JvdXBcIiBbY2xhc3MuYW50LWNvbG9yLXBpY2tlci1zbGlkZXItZ3JvdXAtZGlzYWJsZWQtYWxwaGFdPVwiZGlzYWJsZWRBbHBoYVwiPlxuICAgICAgICAgIDxjb2xvci1zbGlkZXJcbiAgICAgICAgICAgIFtjb2xvcl09XCJjb2xvclZhbHVlXCJcbiAgICAgICAgICAgIFt2YWx1ZV09XCInaHNsKCcgKyBjb2xvclZhbHVlPy50b0hzYigpPy5oICsgJywxMDAlLCA1MCUpJ1wiXG4gICAgICAgICAgICBbZ3JhZGllbnRDb2xvcnNdPVwiaHVlQ29sb3JcIlxuICAgICAgICAgICAgKG56T25DaGFuZ2UpPVwiaGFuZGxlQ2hhbmdlKCRldmVudCwgJ2h1ZScpXCJcbiAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICAobnpPbkNoYW5nZUNvbXBsZXRlKT1cIm56T25DaGFuZ2VDb21wbGV0ZS5lbWl0KCRldmVudClcIlxuICAgICAgICAgID48L2NvbG9yLXNsaWRlcj5cbiAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiIWRpc2FibGVkQWxwaGFcIj5cbiAgICAgICAgICAgIDxjb2xvci1zbGlkZXJcbiAgICAgICAgICAgICAgdHlwZT1cImFscGhhXCJcbiAgICAgICAgICAgICAgW2NvbG9yXT1cImNvbG9yVmFsdWVcIlxuICAgICAgICAgICAgICBbdmFsdWVdPVwidG9SZ2JTdHJpbmdcIlxuICAgICAgICAgICAgICBbZ3JhZGllbnRDb2xvcnNdPVwiZ3JhZGllbnRDb2xvcnNcIlxuICAgICAgICAgICAgICAobnpPbkNoYW5nZSk9XCJoYW5kbGVDaGFuZ2UoJGV2ZW50LCAnYWxwaGEnKVwiXG4gICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICAgIChuek9uQ2hhbmdlQ29tcGxldGUpPVwibnpPbkNoYW5nZUNvbXBsZXRlLmVtaXQoJGV2ZW50KVwiXG4gICAgICAgICAgICA+PC9jb2xvci1zbGlkZXI+XG4gICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8bmctYW50ZC1jb2xvci1ibG9jayBbY29sb3JdPVwidG9SZ2JTdHJpbmdcIj48L25nLWFudGQtY29sb3ItYmxvY2s+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJwYW5lbFJlbmRlckZvb3RlclwiPlxuICAgICAgICA8bmctdGVtcGxhdGUgW25nVGVtcGxhdGVPdXRsZXRdPVwicGFuZWxSZW5kZXJGb290ZXJcIj48L25nLXRlbXBsYXRlPlxuICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgPC9kaXY+XG4gIGBcbn0pXG5leHBvcnQgY2xhc3MgTmdBbnRkQ29sb3JQaWNrZXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcyB7XG4gIEBJbnB1dCgpIHZhbHVlOiBDb2xvclZhbHVlO1xuICBASW5wdXQoKSBkZWZhdWx0VmFsdWU6IENvbG9yVmFsdWU7XG4gIEBPdXRwdXQoKSByZWFkb25seSBuek9uQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjx7IGNvbG9yOiBDb2xvcjsgdHlwZT86IEhzYmFDb2xvclR5cGUgfT4oKTtcbiAgQE91dHB1dCgpIHJlYWRvbmx5IG56T25DaGFuZ2VDb21wbGV0ZSA9IG5ldyBFdmVudEVtaXR0ZXI8SHNiYUNvbG9yVHlwZT4oKTtcbiAgQElucHV0KCkgcGFuZWxSZW5kZXJIZWFkZXI6IFRlbXBsYXRlUmVmPHZvaWQ+IHwgbnVsbCA9IG51bGw7XG4gIEBJbnB1dCgpIHBhbmVsUmVuZGVyRm9vdGVyOiBUZW1wbGF0ZVJlZjx2b2lkPiB8IG51bGwgPSBudWxsO1xuICBASW5wdXQoKSBkaXNhYmxlZEFscGhhOiBib29sZWFuID0gZmFsc2U7XG4gIEBJbnB1dCgpIGRpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgY29sb3JWYWx1ZTogQ29sb3IgfCBudWxsID0gbnVsbDtcbiAgYWxwaGFDb2xvcjogc3RyaW5nID0gJyc7XG5cbiAgaHVlQ29sb3I6IHN0cmluZ1tdID0gW1xuICAgICdyZ2IoMjU1LCAwLCAwKSAwJScsXG4gICAgJ3JnYigyNTUsIDI1NSwgMCkgMTclJyxcbiAgICAncmdiKDAsIDI1NSwgMCkgMzMlJyxcbiAgICAncmdiKDAsIDI1NSwgMjU1KSA1MCUnLFxuICAgICdyZ2IoMCwgMCwgMjU1KSA2NyUnLFxuICAgICdyZ2IoMjU1LCAwLCAyNTUpIDgzJScsXG4gICAgJ3JnYigyNTUsIDAsIDApIDEwMCUnXG4gIF07XG5cbiAgZ3JhZGllbnRDb2xvcnM6IHN0cmluZ1tdID0gWydyZ2JhKDI1NSwgMCwgNCwgMCkgMCUnLCB0aGlzLmFscGhhQ29sb3JdO1xuXG4gIHRvUmdiU3RyaW5nOiBzdHJpbmcgPSB0aGlzLmNvbG9yVmFsdWU/LnRvUmdiU3RyaW5nKCkgfHwgJyc7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBjZHI6IENoYW5nZURldGVjdG9yUmVmKSB7fVxuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIHRoaXMuc2V0Q29sb3JWYWx1ZSh0aGlzLnZhbHVlKTtcbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICBjb25zdCB7IHZhbHVlLCBkZWZhdWx0VmFsdWUgfSA9IGNoYW5nZXM7XG4gICAgaWYgKHZhbHVlIHx8IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgdGhpcy5zZXRDb2xvclZhbHVlKHRoaXMudmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGhhc1ZhbHVlKHZhbHVlOiBDb2xvclZhbHVlKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuICEhdmFsdWU7XG4gIH1cblxuICBzZXRDb2xvclZhbHVlKGNvbG9yOiBDb2xvclZhbHVlKTogdm9pZCB7XG4gICAgbGV0IG1lcmdlU3RhdGU7XG4gICAgaWYgKHRoaXMuaGFzVmFsdWUoY29sb3IpKSB7XG4gICAgICBtZXJnZVN0YXRlID0gY29sb3I7XG4gICAgfSBlbHNlIGlmICh0aGlzLmhhc1ZhbHVlKHRoaXMuZGVmYXVsdFZhbHVlKSkge1xuICAgICAgbWVyZ2VTdGF0ZSA9IHRoaXMuZGVmYXVsdFZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXJnZVN0YXRlID0gZGVmYXVsdENvbG9yO1xuICAgIH1cbiAgICB0aGlzLmNvbG9yVmFsdWUgPSBnZW5lcmF0ZUNvbG9yKG1lcmdlU3RhdGUgYXMgQ29sb3JHZW5JbnB1dCk7XG4gICAgdGhpcy5zZXRBbHBoYUNvbG9yKHRoaXMuY29sb3JWYWx1ZSk7XG4gICAgdGhpcy50b1JnYlN0cmluZyA9IHRoaXMuY29sb3JWYWx1ZT8udG9SZ2JTdHJpbmcoKSB8fCAnJztcbiAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gIH1cblxuICBzZXRBbHBoYUNvbG9yKGNvbG9yVmFsdWU6IENvbG9yKTogdm9pZCB7XG4gICAgY29uc3QgcmdiID0gZ2VuZXJhdGVDb2xvcihjb2xvclZhbHVlLnRvUmdiU3RyaW5nKCkpO1xuICAgIHRoaXMuYWxwaGFDb2xvciA9IHJnYi50b1JnYlN0cmluZygpO1xuICAgIHRoaXMuZ3JhZGllbnRDb2xvcnMgPSBbJ3JnYmEoMjU1LCAwLCA0LCAwKSAwJScsIHRoaXMuYWxwaGFDb2xvcl07XG4gICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gIH1cblxuICBoYW5kbGVDaGFuZ2UoY29sb3I6IENvbG9yLCB0eXBlPzogSHNiYUNvbG9yVHlwZSk6IHZvaWQge1xuICAgIHRoaXMuc2V0Q29sb3JWYWx1ZShjb2xvcik7XG4gICAgdGhpcy5uek9uQ2hhbmdlLmVtaXQoeyBjb2xvciwgdHlwZSB9KTtcbiAgfVxufVxuIl19
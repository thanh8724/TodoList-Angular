import { __decorate } from "tslib";
/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
import { animate, group, query, style } from '@angular/animations';
import { NgTemplateOutlet } from '@angular/common';
import { ChangeDetectionStrategy, Component, Input } from '@angular/core';
import { fromEvent, Subject } from 'rxjs';
import { filter, takeUntil } from 'rxjs/operators';
import { InputBoolean } from 'ng-zorro-antd/core/util';
import * as i0 from "@angular/core";
import * as i1 from "@angular/animations";
import * as i2 from "./graph";
export class NzGraphNodeComponent {
    constructor(ngZone, el, builder, renderer2, graphComponent) {
        this.ngZone = ngZone;
        this.el = el;
        this.builder = builder;
        this.renderer2 = renderer2;
        this.graphComponent = graphComponent;
        this.animationInfo = null;
        this.initialState = true;
        this.destroy$ = new Subject();
        this.animationPlayer = null;
    }
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            fromEvent(this.el.nativeElement, 'click')
                .pipe(filter(event => {
                event.preventDefault();
                return this.graphComponent.nzNodeClick.observers.length > 0;
            }), takeUntil(this.destroy$))
                .subscribe(() => {
                // Re-enter the Angular zone and run the change detection only if there're any `nzNodeClick` listeners,
                // e.g.: `<nz-graph (nzNodeClick)="..."></nz-graph>`.
                this.ngZone.run(() => this.graphComponent.nzNodeClick.emit(this.node));
            });
        });
    }
    ngOnDestroy() {
        this.destroy$.next();
    }
    makeAnimation() {
        const cur = this.getAnimationInfo();
        if (this.animationPlayer) {
            this.animationPlayer.destroy();
        }
        let animationFactory;
        const pre = { ...this.animationInfo };
        if (this.initialState) {
            animationFactory = this.builder.build([
                style({ transform: `translate(${cur.x}px, ${cur.y}px)` }),
                query('g', [
                    style({
                        width: `${cur.width}px`,
                        height: `${cur.height}px`
                    })
                ])
            ]);
            this.initialState = false;
        }
        else {
            animationFactory = this.builder.build([
                style({ transform: `translate(${pre.x}px, ${pre.y}px)` }),
                query('g', [
                    style({
                        width: `${pre.width}px`,
                        height: `${pre.height}px`
                    })
                ]),
                group([
                    query('g', [
                        animate('150ms ease-out', style({
                            width: `${cur.width}px`,
                            height: `${cur.height}px`
                        }))
                    ]),
                    animate('150ms ease-out', style({ transform: `translate(${cur.x}px, ${cur.y}px)` }))
                ])
            ]);
        }
        this.animationInfo = cur;
        this.animationPlayer = animationFactory.create(this.el.nativeElement);
        this.animationPlayer.play();
        const done$ = new Subject();
        this.animationPlayer.onDone(() => {
            // Need this for canvas for now.
            this.renderer2.setAttribute(this.el.nativeElement, 'transform', `translate(${cur.x}, ${cur.y})`);
            done$.next();
            done$.complete();
        });
        return done$.asObservable();
    }
    makeNoAnimation() {
        const cur = this.getAnimationInfo();
        // Need this for canvas for now.
        this.renderer2.setAttribute(this.el.nativeElement, 'transform', `translate(${cur.x}, ${cur.y})`);
    }
    getAnimationInfo() {
        const { x, y } = this.nodeTransform();
        return {
            width: this.node.width,
            height: this.node.height,
            x,
            y
        };
    }
    nodeTransform() {
        const x = this.computeCXPositionOfNodeShape() - this.node.width / 2;
        const y = this.node.y - this.node.height / 2;
        return { x, y };
    }
    computeCXPositionOfNodeShape() {
        if (this.node.expanded) {
            return this.node.x;
        }
        return this.node.x - this.node.width / 2 + this.node.coreBox.width / 2;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: NzGraphNodeComponent, deps: [{ token: i0.NgZone }, { token: i0.ElementRef }, { token: i1.AnimationBuilder }, { token: i0.Renderer2 }, { token: i2.NzGraph }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "17.3.8", type: NzGraphNodeComponent, isStandalone: true, selector: "[nz-graph-node]", inputs: { node: "node", noAnimation: "noAnimation", customTemplate: "customTemplate" }, host: { properties: { "id": "node.id || node.name", "class.nz-graph-node-expanded": "node.expanded", "class.nz-graph-group-node": "node.type===0", "class.nz-graph-base-node": "node.type===1" } }, ngImport: i0, template: `
    <svg:g>
      @if (customTemplate) {
        <ng-container [ngTemplateOutlet]="customTemplate" [ngTemplateOutletContext]="{ $implicit: node }" />
      } @else {
        <svg:rect class="nz-graph-node-rect" [attr.width]="node.width" [attr.height]="node.height"></svg:rect>
        <svg:text x="10" y="20">{{ node.id || node.name }}</svg:text>
      }
    </svg:g>
  `, isInline: true, dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
__decorate([
    InputBoolean()
], NzGraphNodeComponent.prototype, "noAnimation", void 0);
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.8", ngImport: i0, type: NzGraphNodeComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[nz-graph-node]',
                    template: `
    <svg:g>
      @if (customTemplate) {
        <ng-container [ngTemplateOutlet]="customTemplate" [ngTemplateOutletContext]="{ $implicit: node }" />
      } @else {
        <svg:rect class="nz-graph-node-rect" [attr.width]="node.width" [attr.height]="node.height"></svg:rect>
        <svg:text x="10" y="20">{{ node.id || node.name }}</svg:text>
      }
    </svg:g>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    host: {
                        '[id]': 'node.id || node.name',
                        '[class.nz-graph-node-expanded]': 'node.expanded',
                        '[class.nz-graph-group-node]': 'node.type===0',
                        '[class.nz-graph-base-node]': 'node.type===1'
                    },
                    imports: [NgTemplateOutlet],
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.NgZone }, { type: i0.ElementRef }, { type: i1.AnimationBuilder }, { type: i0.Renderer2 }, { type: i2.NzGraph }], propDecorators: { node: [{
                type: Input
            }], noAnimation: [{
                type: Input
            }], customTemplate: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JhcGgtbm9kZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9jb21wb25lbnRzL2dyYXBoL2dyYXBoLW5vZGUuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7O0dBR0c7QUFFSCxPQUFPLEVBQUUsT0FBTyxFQUF1RCxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3hILE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ25ELE9BQU8sRUFDTCx1QkFBdUIsRUFDdkIsU0FBUyxFQUVULEtBQUssRUFNTixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsU0FBUyxFQUFjLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUN0RCxPQUFPLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRW5ELE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQzs7OztBQWlDdkQsTUFBTSxPQUFPLG9CQUFvQjtJQWEvQixZQUNVLE1BQWMsRUFDZCxFQUEyQixFQUMzQixPQUF5QixFQUN6QixTQUFvQixFQUNwQixjQUF1QjtRQUp2QixXQUFNLEdBQU4sTUFBTSxDQUFRO1FBQ2QsT0FBRSxHQUFGLEVBQUUsQ0FBeUI7UUFDM0IsWUFBTyxHQUFQLE9BQU8sQ0FBa0I7UUFDekIsY0FBUyxHQUFULFNBQVMsQ0FBVztRQUNwQixtQkFBYyxHQUFkLGNBQWMsQ0FBUztRQVhqQyxrQkFBYSxHQUFnQixJQUFJLENBQUM7UUFDbEMsaUJBQVksR0FBRyxJQUFJLENBQUM7UUFFWixhQUFRLEdBQUcsSUFBSSxPQUFPLEVBQVEsQ0FBQztRQUMvQixvQkFBZSxHQUEyQixJQUFJLENBQUM7SUFRcEQsQ0FBQztJQUVKLFFBQVE7UUFDTixJQUFJLENBQUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsRUFBRTtZ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QUNqQjtpTEFFVSxJQUFJO3NCQUFaLEtBQUs7Z0JBQ21CLFdBQVc7c0JBQW5DLEtBQUs7Z0JBQ0csY0FBYztzQkFBdEIsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9naXRodWIuY29tL05HLVpPUlJPL25nLXpvcnJvLWFudGQvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICovXG5cbmltcG9ydCB7IGFuaW1hdGUsIEFuaW1hdGlvbkJ1aWxkZXIsIEFuaW1hdGlvbkZhY3RvcnksIEFuaW1hdGlvblBsYXllciwgZ3JvdXAsIHF1ZXJ5LCBzdHlsZSB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHsgTmdUZW1wbGF0ZU91dGxldCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ29tcG9uZW50LFxuICBFbGVtZW50UmVmLFxuICBJbnB1dCxcbiAgTmdab25lLFxuICBPbkRlc3Ryb3ksXG4gIE9uSW5pdCxcbiAgUmVuZGVyZXIyLFxuICBUZW1wbGF0ZVJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGZyb21FdmVudCwgT2JzZXJ2YWJsZSwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZmlsdGVyLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IElucHV0Qm9vbGVhbiB9IGZyb20gJ25nLXpvcnJvLWFudGQvY29yZS91dGlsJztcblxuaW1wb3J0IHsgTnpHcmFwaCB9IGZyb20gJy4vZ3JhcGgnO1xuaW1wb3J0IHsgTnpHcmFwaEdyb3VwTm9kZSwgTnpHcmFwaE5vZGUgfSBmcm9tICcuL2ludGVyZmFjZSc7XG5cbmludGVyZmFjZSBJbmZvIHtcbiAgeDogbnVtYmVyO1xuICB5OiBudW1iZXI7XG4gIHdpZHRoOiBudW1iZXI7XG4gIGhlaWdodDogbnVtYmVyO1xufVxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnW256LWdyYXBoLW5vZGVdJyxcbiAgdGVtcGxhdGU6IGBcbiAgICA8c3ZnOmc+XG4gICAgICBAaWYgKGN1c3RvbVRlbXBsYXRlKSB7XG4gICAgICAgIDxuZy1jb250YWluZXIgW25nVGVtcGxhdGVPdXRsZXRdPVwiY3VzdG9tVGVtcGxhdGVcIiBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwieyAkaW1wbGljaXQ6IG5vZGUgfVwiIC8+XG4gICAgICB9IEBlbHNlIHtcbiAgICAgICAgPHN2ZzpyZWN0IGNsYXNzPVwibnotZ3JhcGgtbm9kZS1yZWN0XCIgW2F0dHIud2lkdGhdPVwibm9kZS53aWR0aFwiIFthdHRyLmhlaWdodF09XCJub2RlLmhlaWdodFwiPjwvc3ZnOnJlY3Q+XG4gICAgICAgIDxzdmc6dGV4dCB4PVwiMTBcIiB5PVwiMjBcIj57eyBub2RlLmlkIHx8IG5vZGUubmFtZSB9fTwvc3ZnOnRleHQ+XG4gICAgICB9XG4gICAgPC9zdmc6Zz5cbiAgYCxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIGhvc3Q6IHtcbiAgICAnW2lkXSc6ICdub2RlLmlkIHx8IG5vZGUubmFtZScsXG4gICAgJ1tjbGFzcy5uei1ncmFwaC1ub2RlLWV4cGFuZGVkXSc6ICdub2RlLmV4cGFuZGVkJyxcbiAgICAnW2NsYXNzLm56LWdyYXBoLWdyb3VwLW5vZGVdJzogJ25vZGUudHlwZT09PTAnLFxuICAgICdbY2xhc3MubnotZ3JhcGgtYmFzZS1ub2RlXSc6ICdub2RlLnR5cGU9PT0xJ1xuICB9LFxuICBpbXBvcnRzOiBbTmdUZW1wbGF0ZU91dGxldF0sXG4gIHN0YW5kYWxvbmU6IHRydWVcbn0pXG5leHBvcnQgY2xhc3MgTnpHcmFwaE5vZGVDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gIEBJbnB1dCgpIG5vZGUhOiBOekdyYXBoTm9kZSB8IE56R3JhcGhHcm91cE5vZGU7XG4gIEBJbnB1dCgpIEBJbnB1dEJvb2xlYW4oKSBub0FuaW1hdGlvbj86IGJvb2xlYW47XG4gIEBJbnB1dCgpIGN1c3RvbVRlbXBsYXRlPzogVGVtcGxhdGVSZWY8e1xuICAgICRpbXBsaWNpdDogTnpHcmFwaE5vZGUgfCBOekdyYXBoR3JvdXBOb2RlO1xuICB9PjtcblxuICBhbmltYXRpb25JbmZvOiBJbmZvIHwgbnVsbCA9IG51bGw7XG4gIGluaXRpYWxTdGF0ZSA9IHRydWU7XG5cbiAgcHJpdmF0ZSBkZXN0cm95JCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gIHByaXZhdGUgYW5pbWF0aW9uUGxheWVyOiBBbmltYXRpb25QbGF5ZXIgfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIG5nWm9uZTogTmdab25lLFxuICAgIHByaXZhdGUgZWw6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+LFxuICAgIHByaXZhdGUgYnVpbGRlcjogQW5pbWF0aW9uQnVpbGRlcixcbiAgICBwcml2YXRlIHJlbmRlcmVyMjogUmVuZGVyZXIyLFxuICAgIHByaXZhdGUgZ3JhcGhDb21wb25lbnQ6IE56R3JhcGhcbiAgKSB7fVxuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgIGZyb21FdmVudDxNb3VzZUV2ZW50Pih0aGlzLmVsLm5hdGl2ZUVsZW1lbnQsICdjbGljaycpXG4gICAgICAgIC5waXBlKFxuICAgICAgICAgIGZpbHRlcihldmVudCA9PiB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ3JhcGhDb21wb25lbnQubnpOb2RlQ2xpY2sub2JzZXJ2ZXJzLmxlbmd0aCA+IDA7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpXG4gICAgICAgIClcbiAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgLy8gUmUtZW50ZXIgdGhlIEFuZ3VsYXIgem9uZSBhbmQgcnVuIHRoZSBjaGFuZ2UgZGV0ZWN0aW9uIG9ubHkgaWYgdGhlcmUncmUgYW55IGBuek5vZGVDbGlja2AgbGlzdGVuZXJzLFxuICAgICAgICAgIC8vIGUuZy46IGA8bnotZ3JhcGggKG56Tm9kZUNsaWNrKT1cIi4uLlwiPjwvbnotZ3JhcGg+YC5cbiAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oKCkgPT4gdGhpcy5ncmFwaENvbXBvbmVudC5uek5vZGVDbGljay5lbWl0KHRoaXMubm9kZSkpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuZGVzdHJveSQubmV4dCgpO1xuICB9XG5cbiAgbWFrZUFuaW1hdGlvbigpOiBPYnNlcnZhYmxlPHZvaWQ+IHtcbiAgICBjb25zdCBjdXIgPSB0aGlzLmdldEFuaW1hdGlvbkluZm8oKTtcbiAgICBpZiAodGhpcy5hbmltYXRpb25QbGF5ZXIpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uUGxheWVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgbGV0IGFuaW1hdGlvbkZhY3Rvcnk6IEFuaW1hdGlvbkZhY3Rvcnk7XG4gICAgY29uc3QgcHJlID0geyAuLi50aGlzLmFuaW1hdGlvbkluZm8gfSBhcyBJbmZvO1xuXG4gICAgaWYgKHRoaXMuaW5pdGlhbFN0YXRlKSB7XG4gICAgICBhbmltYXRpb25GYWN0b3J5ID0gdGhpcy5idWlsZGVyLmJ1aWxkKFtcbiAgICAgICAgc3R5bGUoeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHtjdXIueH1weCwgJHtjdXIueX1weClgIH0pLFxuICAgICAgICBxdWVyeSgnZycsIFtcbiAgICAgICAgICBzdHlsZSh7XG4gICAgICAgICAgICB3aWR0aDogYCR7Y3VyLndpZHRofXB4YCxcbiAgICAgICAgICAgIGhlaWdodDogYCR7Y3VyLmhlaWdodH1weGBcbiAgICAgICAgICB9KVxuICAgICAgICBdKVxuICAgICAgXSk7XG4gICAgICB0aGlzLmluaXRpYWxTdGF0ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbmltYXRpb25GYWN0b3J5ID0gdGhpcy5idWlsZGVyLmJ1aWxkKFtcbiAgICAgICAgc3R5bGUoeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHtwcmUhLnh9cHgsICR7cHJlIS55fXB4KWAgfSksXG4gICAgICAgIHF1ZXJ5KCdnJywgW1xuICAgICAgICAgIHN0eWxlKHtcbiAgICAgICAgICAgIHdpZHRoOiBgJHtwcmUhLndpZHRofXB4YCxcbiAgICAgICAgICAgIGhlaWdodDogYCR7cHJlIS5oZWlnaHR9cHhgXG4gICAgICAgICAgfSlcbiAgICAgICAgXSksXG4gICAgICAgIGdyb3VwKFtcbiAgICAgICAgICBxdWVyeSgnZycsIFtcbiAgICAgICAgICAgIGFuaW1hdGUoXG4gICAgICAgICAgICAgICcxNTBtcyBlYXNlLW91dCcsXG4gICAgICAgICAgICAgIHN0eWxlKHtcbiAgICAgICAgICAgICAgICB3aWR0aDogYCR7Y3VyLndpZHRofXB4YCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGAke2N1ci5oZWlnaHR9cHhgXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgXSksXG4gICAgICAgICAgYW5pbWF0ZSgnMTUwbXMgZWFzZS1vdXQnLCBzdHlsZSh7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgke2N1ci54fXB4LCAke2N1ci55fXB4KWAgfSkpXG4gICAgICAgIF0pXG4gICAgICBdKTtcbiAgICB9XG4gICAgdGhpcy5hbmltYXRpb25JbmZvID0gY3VyO1xuICAgIHRoaXMuYW5pbWF0aW9uUGxheWVyID0gYW5pbWF0aW9uRmFjdG9yeS5jcmVhdGUodGhpcy5lbC5uYXRpdmVFbGVtZW50KTtcbiAgICB0aGlzLmFuaW1hdGlvblBsYXllci5wbGF5KCk7XG4gICAgY29uc3QgZG9uZSQgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICAgIHRoaXMuYW5pbWF0aW9uUGxheWVyLm9uRG9uZSgoKSA9PiB7XG4gICAgICAvLyBOZWVkIHRoaXMgZm9yIGNhbnZhcyBmb3Igbm93LlxuICAgICAgdGhpcy5yZW5kZXJlcjIuc2V0QXR0cmlidXRlKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHtjdXIueH0sICR7Y3VyLnl9KWApO1xuICAgICAgZG9uZSQubmV4dCgpO1xuICAgICAgZG9uZSQuY29tcGxldGUoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZG9uZSQuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICBtYWtlTm9BbmltYXRpb24oKTogdm9pZCB7XG4gICAgY29uc3QgY3VyID0gdGhpcy5nZXRBbmltYXRpb25JbmZvKCk7XG4gICAgLy8gTmVlZCB0aGlzIGZvciBjYW52YXMgZm9yIG5vdy5cbiAgICB0aGlzLnJlbmRlcmVyMi5zZXRBdHRyaWJ1dGUodGhpcy5lbC5uYXRpdmVFbGVtZW50LCAndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke2N1ci54fSwgJHtjdXIueX0pYCk7XG4gIH1cblxuICBnZXRBbmltYXRpb25JbmZvKCk6IEluZm8ge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy5ub2RlVHJhbnNmb3JtKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB0aGlzLm5vZGUud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMubm9kZS5oZWlnaHQsXG4gICAgICB4LFxuICAgICAgeVxuICAgIH07XG4gIH1cblxuICBub2RlVHJhbnNmb3JtKCk6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSB7XG4gICAgY29uc3QgeCA9IHRoaXMuY29tcHV0ZUNYUG9zaXRpb25PZk5vZGVTaGFwZSgpIC0gdGhpcy5ub2RlLndpZHRoIC8gMjtcbiAgICBjb25zdCB5ID0gdGhpcy5ub2RlLnkgLSB0aGlzLm5vZGUuaGVpZ2h0IC8gMjtcbiAgICByZXR1cm4geyB4LCB5IH07XG4gIH1cblxuICBjb21wdXRlQ1hQb3NpdGlvbk9mTm9kZVNoYXBlKCk6IG51bWJlciB7XG4gICAgaWYgKCh0aGlzLm5vZGUgYXMgTnpHcmFwaEdyb3VwTm9kZSkuZXhwYW5kZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGUueDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubm9kZS54IC0gdGhpcy5ub2RlLndpZHRoIC8gMiArIHRoaXMubm9kZS5jb3JlQm94LndpZHRoIC8gMjtcbiAgfVxufVxuIl19